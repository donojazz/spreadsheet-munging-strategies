[
["tidyish.html", "2 Tidy-ish tables", " 2 Tidy-ish tables This chapter is a gentle introduction, by taking what you already know about importing tidy tabular data (with read.csv() or the readr package), and shows you how to how to do the same things with tidyxl and unpivotr. It works up to tables that are mostly tidy, but have subtle problems. "],
["tidy-clean.html", "2.1 Clean &amp; tidy tables", " 2.1 Clean &amp; tidy tables If the tables in the spreadsheet are clean and tidy, then you should use a package like readxl. But it’s worth knowing how to emulate readxl with tidyxl and unpivotr, because some almost clean tables can be handled using these techniques. Clean and tidy means One table per sheet A single row of column headers, or no headers A single data type in each column Only one kind of sentinel value (to be interpreted as NA) No meaningful formatting No data buried in formulas No need to refer to named ranges Here’s the full process. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) xlsx_cells(path, sheet = &quot;clean&quot;) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(row, data_type, header, character, numeric) %&gt;% spatter(header) %&gt;% select(-row) ## # A tibble: 3 x 2 ## Age Name ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 Matilda ## 2 3 Nicholas ## 3 5 Olivia tidyxl::xlsx_cells() imports the spreadsheet into a data frame, where each row of the data frame describes one cell of the spreadsheet. The columns row and col (and address) describe the position of the cell, and the value of the cell is in one of the columns error, logical, numeric, date, character, depending on the type of data in the cell. The column data_type says which column the value is in. Other columns describe formatting and formulas. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) xlsx_cells(path, sheet = &quot;clean&quot;) %&gt;% select(row, col, data_type, character, numeric) ## # A tibble: 8 x 5 ## row col data_type character numeric ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 1 character Name NA ## 2 1 2 character Age NA ## 3 2 1 character Matilda NA ## 4 2 2 numeric &lt;NA&gt; 1 ## 5 3 1 character Nicholas NA ## 6 3 2 numeric &lt;NA&gt; 3 ## 7 4 1 character Olivia NA ## 8 4 2 numeric &lt;NA&gt; 5 unpivotr::behead() takes one level of headers from a pivot table and makes it part of the data. Think of it like tidyr::gather(), except that it works when there is more than one row of headers (or more than one column of row-headers), and it only works on tables that have first come through unpivotr::as_cells() or tidyxl::xlsx_cells(). xlsx_cells(path, sheet = &quot;clean&quot;) %&gt;% select(row, col, data_type, character, numeric) %&gt;% behead(&quot;N&quot;, header) ## # A tibble: 6 x 6 ## row col data_type character numeric header ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2 1 character Matilda NA Name ## 2 2 2 numeric &lt;NA&gt; 1 Age ## 3 3 1 character Nicholas NA Name ## 4 3 2 numeric &lt;NA&gt; 3 Age ## 5 4 1 character Olivia NA Name ## 6 4 2 numeric &lt;NA&gt; 5 Age unpivotr::spatter() spreads key-value pairs across multiple columns, like tidyxl::spread(), except that it handles mixed data types. It knows which column contains the cell value (i.e. the character column or the numeric column), by checking the data_type column. Just like tidyr::spread(), it can be confused by extraneous data, so it’s usually a good idea to drop the col column first, and to keep the row column. xlsx_cells(path, sheet = &quot;clean&quot;) %&gt;% select(row, col, data_type, character, numeric) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(-col) %&gt;% spatter(header) %&gt;% select(-row) ## # A tibble: 3 x 2 ## Age Name ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 Matilda ## 2 3 Nicholas ## 3 5 Olivia In case the table has no column headers, you can spatter the col column instead of a nonexistent header column. xlsx_cells(path, sheet = &quot;clean&quot;) %&gt;% dplyr::filter(row &gt;= 2) %&gt;% select(row, col, data_type, character, numeric) %&gt;% spatter(col) %&gt;% select(-row) ## # A tibble: 3 x 2 ## `1` `2` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Matilda 1 ## 2 Nicholas 3 ## 3 Olivia 5 Tidyxl and unpivotr are much more complicated than readxl, and that’s the point: tidyxl and unpivotr give you more power and complexity when you need it. read_excel(path, sheet = &quot;clean&quot;) ## # A tibble: 3 x 2 ## Name Age ## &lt;chr&gt; &lt;dbl&gt; ## 1 Matilda 1 ## 2 Nicholas 3 ## 3 Olivia 5 read_excel(path, sheet = &quot;clean&quot;, col_names = FALSE, skip = 1) ## # A tibble: 3 x 2 ## X__1 X__2 ## &lt;chr&gt; &lt;dbl&gt; ## 1 Matilda 1 ## 2 Nicholas 3 ## 3 Olivia 5 "],
["almost-tidy-tables.html", "2.2 Almost-tidy tables", " 2.2 Almost-tidy tables For tables that are already ‘tidy’ (a single row of column headers), use packages like readxl that specialise in importing tidy data. For everything else, read on. 2.2.1 Transposed (headers in the first row, data extends to the right) Most packages for importing data assume that the headers are in the first row, and each row of data is an observation. They usually don’t support the alternative: headers in the first column, and each column of data is an observation. You can hack a way around this by importing without recognising any headers, transposing with t() (which outputs a matrix), placing the headers as names, and converting back to a data frame, but this almost always results in all the data types being converted. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) read_excel(path, sheet = &quot;transposed&quot;, col_names = FALSE) %&gt;% t() %&gt;% `colnames&lt;-`(.[1, ]) %&gt;% .[-1, ] %&gt;% as_tibble() ## # A tibble: 3 x 2 ## Name Age ## &lt;chr&gt; &lt;chr&gt; ## 1 Matilda 1 ## 2 Nicholas 3 ## 3 Olivia 5 Tidyxl and unpivotr are agnostic to the layout of tables. Importing the transpose is the same is importing the usual layout, merely using the &quot;W&quot; (west) direction instead of &quot;N&quot; (north) when beheading the headers. xlsx_cells(path, sheet = &quot;transposed&quot;) %&gt;% behead(&quot;W&quot;, header) %&gt;% select(col, data_type, header, character, numeric) %&gt;% spatter(header) %&gt;% select(Name, Age) ## # A tibble: 3 x 2 ## Name Age ## &lt;chr&gt; &lt;dbl&gt; ## 1 Matilda 1 ## 2 Nicholas 3 ## 3 Olivia 5 2.2.2 Other stuff on the same sheet It will be more complicated when the table doesn’t begin in cell A1, or if there are non-blank cells above, below or either side of the table. If you know at coding time which rows and columns the table occupies, then you can do the following. Blank or non-blank cells above the table: use the skip argument of readxl::read_excel(). Blank or non-blank cells either side of the table: use the col_types argument of readxl::read_excel() to ignore those columns. Blank or non-blank cells below the table: use n_max argument of readxl::read_excel() to ignore those rows. path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) readxl::read_excel(path, sheet = &quot;notes&quot;, skip = 2, n_max = 33, col_types = c(&quot;guess&quot;, &quot;guess&quot;, &quot;skip&quot;)) %&gt;% drop_na() ## # A tibble: 2 x 2 ## Name Age ## &lt;chr&gt; &lt;dbl&gt; ## 1 Matilda 1 ## 2 Nicholas 3 If you don’t know at coding time which rows and columns the table occupies ( e.g. when the latest version of the spreadsheet is published and the table has moved), then one strategy is to read the spreadsheet with tidyxl::xlsx_cells() first, and inspect the results to determine the boundaries of the table. Then use those boundaries as the skip, n_max and col_types arguments to readxl::read_excel() Read the spreadsheet with tidyxl::xlsx_cells(). Filter the result for sentinel values, e.g. the cells containing the first and final column headers, and a cell in the final row of data. Construct the arguments skip, n_max and col_types so that readxl::read_excel() gets the exact dimensions of the table. # Step 1: read the spreadsheet and filter for sentinel values to detect the # top-left and bottom-right cells cells &lt;- xlsx_cells(path, sheet = &quot;notes&quot;) rectify(cells) ## # A tibble: 7 x 5 ## `row/col` `1(A)` `2(B)` `3(C)` `4(D)` ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Title text &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 3 &lt;NA&gt; Name Age &lt;NA&gt; ## 4 4 &lt;NA&gt; Matilda 1 &lt;NA&gt; ## 5 5 &lt;NA&gt; Nicholas 3 &lt;NA&gt; ## 6 6 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 7 7 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; Footnote top_left &lt;- dplyr::filter(cells, character == &quot;Name&quot;) %&gt;% select(row, col) top_left ## # A tibble: 1 x 2 ## row col ## &lt;int&gt; &lt;int&gt; ## 1 3 2 # It can be tricky to find the bottom-right cell because you have to make some # assumptions. Here we assume that only cells within the table are numeric. bottom_right &lt;- dplyr::filter(cells, data_type == &quot;numeric&quot;) %&gt;% summarise(row = max(row), col = max(col)) bottom_right ## # A tibble: 1 x 2 ## row col ## &lt;dbl&gt; &lt;dbl&gt; ## 1 5 3 # Step 2: construct the arguments `skip` and `n_max` for read_excel() skip &lt;- top_left$row - 1L n_rows &lt;- bottom_right$row - skip read_excel(path, sheet = &quot;notes&quot;, skip = skip, n_max = n_rows) ## # A tibble: 2 x 2 ## Name Age ## &lt;chr&gt; &lt;dbl&gt; ## 1 Matilda 1 ## 2 Nicholas 3 Here’s another way using only tidyxl and unpivotr. # Step 2: filter for cells between the top-left and bottom-right, and spatter # into a table cells %&gt;% dplyr::filter(between(row, top_left$row, bottom_right$row), between(col, top_left$col, bottom_right$col)) %&gt;% select(row, col, data_type, character, numeric) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(-col) %&gt;% spatter(header) %&gt;% select(-row) ## # A tibble: 2 x 2 ## Age Name ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 Matilda ## 2 3 Nicholas "],
["tidy-formatted-rows.html", "2.3 Meaningfully formatted rows", " 2.3 Meaningfully formatted rows As with clean, tidy tables, but with a second step to interpret the formatting. Sometimes whole rows in a table are highlighted by formatting them with, say, a bright yellow fill. The highlighting could mean “this observation should be ignored”, or “this product is no longer available”. Different colours could mean different levels of a hierarchy, e.g. green for “pass” and red for “fail”. There are three steps to interpreting this. Import the table, taking only the cell values and ignoring the formatting. Import one column of the table, taking only the formatting and not the cell values. Use dplyr::bind_cols() to append the column of formatting to the table of cell values. You can then interpret the formatting however you like. Step 1 is the same as clean, tidy tables. Step 2 uses tidyxl::xlsx_cells() to load the data, tidyxl::xlsx_formats(), and several tidyverse functions to link the two and filter for only one column. Why only one column? Because if a whole row is highlighted, then you only need to know the highlighting of one column to know the highlighting of all the others. This is a special case of the following section, meaningfully formatted cells. Here dplyr::bind_cols() can be used as a shortcut, because we are joining exactly n rows of formatting to n rows of data. The following sections is a more general case that can be used instead of this procedure. # Step 1: import the table taking only cell values and ignoring the formatting path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) x &lt;- read_excel(path, sheet = &quot;highlights&quot;) # Step 2: import one column of the table, taking only the formatting and not the # cell values # `formats` is a pallette of fill colours that can be indexed by the # `local_format_id` of a given cell to get the fill colour of that cell fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb # Import all the cells, filter out the header row, filter for the first column, # and create a new column `fill_colour` of the fill colours, by looking up the # local_format_id of each cell in the `fill_colours` pallette. fills &lt;- xlsx_cells(path, sheet = &quot;highlights&quot;) %&gt;% dplyr::filter(row &gt;= 2, col == 1) %&gt;% # Omit the header row mutate(fill_colour = fill_colours[local_format_id]) %&gt;% select(fill_colour) # Step 3: append the `fill` column to the rest of the data bind_cols(x, fills) %&gt;% select(Age, Height, fill_colour) ## # A tibble: 3 x 3 ## Age Height fill_colour ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 2 &lt;NA&gt; ## 2 3 4 FFFFFF00 ## 3 5 6 &lt;NA&gt; Note that the fill colour is expressed as an RGB value with transparency in the first two letters, e.g. FFFFFF00 is FF (opaque), with FFFF00 (yellow). Here’s another way using only tidyxl and unpivotr. fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb xlsx_cells(path, sheet = &quot;highlights&quot;) %&gt;% mutate(fill_colour = fill_colours[local_format_id]) %&gt;% select(row, col, data_type, character, numeric, fill_colour) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(-col, -character) %&gt;% spatter(header) %&gt;% select(-row) ## # A tibble: 3 x 3 ## fill_colour Age Height ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 &lt;NA&gt; 1 2 ## 2 FFFFFF00 3 4 ## 3 &lt;NA&gt; 5 6 "],
["tidy-formatted-cells.html", "2.4 Meaningfully formatted cells", " 2.4 Meaningfully formatted cells If single cells are highlighted, rather than whole rows, then the highlights probably indicate something about the column rather than the row. For example, a highlighted cell in a column called “age” of a table of medical patients, might mean “the age of this patient is uncertain”. One way to deal with this is to create a new column in the final table for each column in the original that has any highlighted cells. For example, if highlighted cells mean “this value is uncertain”, and some cells in the age and height columns are highlighted, then you could create two new columns: uncertain_age, and uncertain_height, by following the procedure of meaningfully formatted rows for each column age and height. # Step 1: import the table taking only cell values and ignoring the formatting path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) x &lt;- read_excel(path, sheet = &quot;annotations&quot;) # Step 2: import one column of the table, taking only the formatting and not the # cell values # `formats` is a pallette of fill colours that can be indexed by the # `local_format_id` of a given cell to get the fill colour of that cell fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb # Import all the cells, filter out the header row, filter for the first column, # and create new columns `something_fill` of the fill colours, by looking up the # local_format_id of each cell in the `formats` pallette. fills &lt;- xlsx_cells(path, sheet = &quot;annotations&quot;) %&gt;% dplyr::filter(row &gt;= 2, col &gt;= 2) %&gt;% # Omit the header row and name column mutate(fill_colour = fill_colours[local_format_id]) %&gt;% select(row, col, fill_colour) %&gt;% spread(col, fill_colour) %&gt;% select(-row) %&gt;% set_names(paste0(colnames(x)[-1], &quot;_fill&quot;)) fills ## # A tibble: 3 x 2 ## Age_fill Height_fill ## &lt;chr&gt; &lt;chr&gt; ## 1 &lt;NA&gt; &lt;NA&gt; ## 2 FFFFFF00 &lt;NA&gt; ## 3 &lt;NA&gt; FF92D050 # Step 3: append the `fill` column to the rest of the data bind_cols(x, fills) ## # A tibble: 3 x 5 ## Name Age Height Age_fill Height_fill ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Matilda 1 2 &lt;NA&gt; &lt;NA&gt; ## 2 Nicholas 3 4 FFFFFF00 &lt;NA&gt; ## 3 Olivia 5 6 &lt;NA&gt; FF92D050 Here’s the same thing, but using only tidyxl and unpivotr fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb cells &lt;- xlsx_cells(path, sheet = &quot;annotations&quot;) %&gt;% mutate(fill_colour = fill_colours[local_format_id]) %&gt;% select(row, col, data_type, character, numeric, fill_colour) cells ## # A tibble: 12 x 6 ## row col data_type character numeric fill_colour ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 1 character Name NA &lt;NA&gt; ## 2 1 2 character Age NA &lt;NA&gt; ## 3 1 3 character Height NA &lt;NA&gt; ## 4 2 1 character Matilda NA &lt;NA&gt; ## 5 2 2 numeric &lt;NA&gt; 1 &lt;NA&gt; ## 6 2 3 numeric &lt;NA&gt; 2 &lt;NA&gt; ## 7 3 1 character Nicholas NA &lt;NA&gt; ## 8 3 2 numeric &lt;NA&gt; 3 FFFFFF00 ## 9 3 3 numeric &lt;NA&gt; 4 &lt;NA&gt; ## 10 4 1 character Olivia NA &lt;NA&gt; ## 11 4 2 numeric &lt;NA&gt; 5 &lt;NA&gt; ## 12 4 3 numeric &lt;NA&gt; 6 FF92D050 values &lt;- cells %&gt;% select(-fill_colour) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(-col) %&gt;% spatter(header) values ## # A tibble: 3 x 4 ## row Age Height Name ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2 1 2 Matilda ## 2 3 3 4 Nicholas ## 3 4 5 6 Olivia fills &lt;- cells %&gt;% behead(&quot;N&quot;, header) %&gt;% mutate(header = paste0(header, &quot;_fill&quot;)) %&gt;% select(row, header, fill_colour) %&gt;% spread(header, fill_colour) fills ## # A tibble: 3 x 4 ## row Age_fill Height_fill Name_fill ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 3 FFFFFF00 &lt;NA&gt; &lt;NA&gt; ## 3 4 &lt;NA&gt; FF92D050 &lt;NA&gt; left_join(values, fills, by = &quot;row&quot;) %&gt;% select(-row) ## # A tibble: 3 x 6 ## Age Height Name Age_fill Height_fill Name_fill ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 2 Matilda &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 3 4 Nicholas FFFFFF00 &lt;NA&gt; &lt;NA&gt; ## 3 5 6 Olivia &lt;NA&gt; FF92D050 &lt;NA&gt; Another way would be to make the table what I call “extra-tidy”. If it is tidy, then each row is an observation, and each column is a variable. To make it “extra-tidy”, you gather() the variables so that each row is one observation of one variable. This works best when every variable has the same data type, otherwise the values will be coerced, probably to a character. # Tidy (x &lt;- read_excel(path, sheet = &quot;annotations&quot;)) ## # A tibble: 3 x 3 ## Name Age Height ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Matilda 1 2 ## 2 Nicholas 3 4 ## 3 Olivia 5 6 # Extra-tidy extra_tidy &lt;- x %&gt;% gather(variable, value, -Name) %&gt;% arrange(Name, variable) extra_tidy ## # A tibble: 6 x 3 ## Name variable value ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Matilda Age 1 ## 2 Matilda Height 2 ## 3 Nicholas Age 3 ## 4 Nicholas Height 4 ## 5 Olivia Age 5 ## 6 Olivia Height 6 With an extra-tidy dataset, the formatting can now be appended to the values of individual variables, rather than to whole observations. # Extra-tidy, with row and column numbers of the original variables extra_tidy &lt;- read_excel(path, sheet = &quot;annotations&quot;) %&gt;% mutate(row = row_number() + 1L) %&gt;% gather(variable, value, -row, -Name) %&gt;% group_by(row) %&gt;% mutate(col = row_number() + 1L) %&gt;% ungroup() %&gt;% select(row, col, Name, variable, value) %&gt;% arrange(row, col) extra_tidy ## # A tibble: 6 x 5 ## row col Name variable value ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 2 Matilda Age 1 ## 2 2 3 Matilda Height 2 ## 3 3 2 Nicholas Age 3 ## 4 3 3 Nicholas Height 4 ## 5 4 2 Olivia Age 5 ## 6 4 3 Olivia Height 6 # `formats` is a pallette of fill colours that can be indexed by the # `local_format_id` of a given cell to get the fill colour of that cell fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb # Import all the cells, filter out the header row, filter for the first column, # and create a new column `uncertain` based on the fill colours, by looking up # the local_format_id of each cell in the `formats` pallette. fills &lt;- xlsx_cells(path, sheet = &quot;annotations&quot;) %&gt;% dplyr::filter(row &gt;= 2, col &gt;= 2) %&gt;% # Omit the header row and name column mutate(fill_colour = fill_colours[local_format_id]) %&gt;% select(row, col, fill_colour) fills ## # A tibble: 6 x 3 ## row col fill_colour ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 2 2 &lt;NA&gt; ## 2 2 3 &lt;NA&gt; ## 3 3 2 FFFFFF00 ## 4 3 3 &lt;NA&gt; ## 5 4 2 &lt;NA&gt; ## 6 4 3 FF92D050 # Step 3: append the `fill` column to the rest of the data left_join(extra_tidy, fills, by = c(&quot;row&quot;, &quot;col&quot;)) ## # A tibble: 6 x 6 ## row col Name variable value fill_colour ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2 2 Matilda Age 1 &lt;NA&gt; ## 2 2 3 Matilda Height 2 &lt;NA&gt; ## 3 3 2 Nicholas Age 3 FFFFFF00 ## 4 3 3 Nicholas Height 4 &lt;NA&gt; ## 5 4 2 Olivia Age 5 &lt;NA&gt; ## 6 4 3 Olivia Height 6 FF92D050 Here’s the same extra-tidy version, but using only tidyxl and unpivotr. fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb xlsx_cells(path, sheet = &quot;annotations&quot;) %&gt;% mutate(fill_colour = fill_colours[local_format_id]) %&gt;% select(row, col, data_type, character, numeric, fill_colour) %&gt;% behead(&quot;W&quot;, Name) %&gt;% behead(&quot;N&quot;, variable) %&gt;% select(-data_type, -character, value = numeric) ## # A tibble: 6 x 6 ## row col value fill_colour Name variable ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 2 1 &lt;NA&gt; Matilda Age ## 2 2 3 2 &lt;NA&gt; Matilda Height ## 3 3 2 3 FFFFFF00 Nicholas Age ## 4 3 3 4 &lt;NA&gt; Nicholas Height ## 5 4 2 5 &lt;NA&gt; Olivia Age ## 6 4 3 6 FF92D050 Olivia Height "],
["layered-formatting.html", "2.5 Layered meaningful formatting", " 2.5 Layered meaningful formatting Sometimes different kinds of formatting relate to clearly different aspects of an observation, e.g. yellow highlight for “uncertain data” and red text for “product no longer available”. Both yellow highlighting and red text in the same row would indicate uncertain data and unavailability of the product at the same time. Deal with it by reading each kind of formatting into a separate column, e.g. fill colour into one column, font colour into another, bold/not-bold into a another, etc. # Step 1: import the table taking only cell values and ignoring the formatting path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) x &lt;- read_excel(path, sheet = &quot;combined-highlights&quot;) # Step 2: import one kind of formatting of one column of the table # `formats` is a pallette of fill colours that can be indexed by the # `local_format_id` of a given cell to get the fill colour of that cell fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb font_colours &lt;- xlsx_formats(path)$local$font$color$rgb # Import all the cells, filter out the header row, filter for the first column, # and create a new column `fill` of the fill colours, by looking up the # local_format_id of each cell in the `formats` pallette. formats &lt;- xlsx_cells(path, sheet = &quot;combined-highlights&quot;) %&gt;% dplyr::filter(row &gt;= 2, col == 1) %&gt;% # Omit the header row mutate(fill_colour = fill_colours[local_format_id], font_colour = font_colours[local_format_id]) %&gt;% select(fill_colour, font_colour) # Step 3: append the `fill` column to the rest of the data bind_cols(x, formats) ## # A tibble: 4 x 5 ## Name Weight Price fill_colour font_colour ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Knife 7 8 &lt;NA&gt; FF000000 ## 2 Fork 5 6 FFFFFF00 FF000000 ## 3 Spoon 3 4 &lt;NA&gt; FFFF0000 ## 4 Teaspoon 1 2 FFFFFF00 FFFF0000 Here’s the same thing, but using only tidyxl and unpivotr. fill_colours &lt;- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb font_colours &lt;- xlsx_formats(path)$local$font$color$rgb cells &lt;- xlsx_cells(path, sheet = &quot;combined-highlights&quot;) %&gt;% mutate(fill_colour = fill_colours[local_format_id], font_colour = font_colours[local_format_id]) %&gt;% select(row, col, data_type, character, numeric, fill_colour, font_colour) %&gt;% behead(&quot;N&quot;, header) %&gt;% behead(&quot;W&quot;, Name) %&gt;% select(-col, -character) values &lt;- cells %&gt;% select(-fill_colour, -font_colour) %&gt;% spread(header, numeric) formats &lt;- distinct(cells, row, fill_colour, font_colour) left_join(values, formats, by = &quot;row&quot;) %&gt;% select(-row) ## # A tibble: 4 x 6 ## data_type Name Price Weight fill_colour font_colour ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 numeric Knife 8 7 &lt;NA&gt; FF000000 ## 2 numeric Fork 6 5 FFFFFF00 &lt;NA&gt; ## 3 numeric Spoon 4 3 &lt;NA&gt; FFFF0000 ## 4 numeric Teaspoon 2 1 FFFFFF00 FFFF0000 "],
["hierarchies-in-formatting.html", "2.6 Hierarchies in formatting", " 2.6 Hierarchies in formatting Different kinds of formatting might also represent different levels of a hierarchy, e.g. formatting interpretation none good italic satisfactory bold poor bold &amp; italic fail When each kind of formatting relates to a different level of one hierarchy, import the different kinds of formatting into different columns, and then combine them into a third column, perhaps using paste(), or case_when(). # Step 1: import the table taking only cell values and ignoring the formatting x &lt;- read_excel(path, sheet = &quot;highlight-hierarchy&quot;) x ## # A tibble: 4 x 2 ## Name Score ## &lt;chr&gt; &lt;dbl&gt; ## 1 Matilda 7 ## 2 Nicholas 5 ## 3 Olivia 3 ## 4 Paul 1 # Step 2: import one kind of formatting of one column of the table # `formats` is a pallette of fill colours that can be indexed by the # `local_format_id` of a given cell to get the fill colour of that cell bold &lt;- xlsx_formats(path)$local$font$bold italic &lt;- xlsx_formats(path)$local$font$italic # Import all the cells, filter out the header row, filter for the first column, # and create a new column `fill` of the fill colours, by looking up the # local_format_id of each cell in the `formats` pallette. formats &lt;- xlsx_cells(path, sheet = &quot;highlight-hierarchy&quot;) %&gt;% dplyr::filter(row &gt;= 2, col == 1) %&gt;% # Omit the header row mutate(bold = bold[local_format_id], italic = italic[local_format_id]) %&gt;% mutate(grade = case_when(bold &amp; italic ~ &quot;fail&quot;, bold ~ &quot;poor&quot;, italic ~ &quot;satisfactory&quot;, TRUE ~ &quot;good&quot;)) %&gt;% select(bold, italic, grade) # Step 3: append the `fill` column to the rest of the data bind_cols(x, formats) ## # A tibble: 4 x 5 ## Name Score bold italic grade ## &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;chr&gt; ## 1 Matilda 7 FALSE FALSE good ## 2 Nicholas 5 FALSE TRUE satisfactory ## 3 Olivia 3 TRUE FALSE poor ## 4 Paul 1 TRUE TRUE fail Here it is again, using only tidyxl and unpivotr. bold &lt;- xlsx_formats(path)$local$font$bold italic &lt;- xlsx_formats(path)$local$font$italic xlsx_cells(path, sheet = &quot;highlight-hierarchy&quot;) %&gt;% mutate(bold = bold[local_format_id], italic = italic[local_format_id]) %&gt;% mutate(grade = case_when(bold &amp; italic ~ &quot;fail&quot;, bold ~ &quot;poor&quot;, italic ~ &quot;satisfactory&quot;, TRUE ~ &quot;good&quot;)) %&gt;% select(row, col, data_type, character, numeric, bold, italic, grade) %&gt;% behead(&quot;N&quot;, header) %&gt;% select(-col) %&gt;% spatter(header) ## # A tibble: 4 x 6 ## row bold italic grade Name Score ## &lt;int&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 FALSE FALSE good Matilda 7 ## 2 3 FALSE TRUE satisfactory Nicholas 5 ## 3 4 TRUE FALSE poor Olivia 3 ## 4 5 TRUE TRUE fail Paul 1 "],
["tidy-sentinel.html", "2.7 Sentinel values in non-text columns", " 2.7 Sentinel values in non-text columns R packages like readr recognise NA as a sentinel value that means “Not Applicable”, or “Not Available”, or anything you want. It doesn’t affect the data type of a column when NA is one of the values. Some datasets use other symbols as a sentinel value, e.g. N/A or ., or a combination, in which case you can instruct readr to interpret those values as sentinels, and it will import them all as NA. But what if the data uses more than one kind of sentinel value. For example, Statistics New Zealand uses … to mean “Not applicable”, and ..C to mean “Confidentialised”. Most tools will either regard both values as NA, or coerce the whole column to characters. read_csv(&quot;a, b, c 1, 2, 3 4, …, ..C&quot;, na = c(&quot;…&quot;, &quot;..C&quot;)) # Regard both values as NA ## # A tibble: 2 x 3 ## a b c ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 3 ## 2 4 NA NA read_csv(&quot;a, b, c 1, 2, 3 4, …, ..C&quot;, na = &quot;&quot;) # Coerce the whole column to characters ## # A tibble: 2 x 3 ## a b c ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 2 3 ## 2 4 … ..C A better procedure is to import the sentinel values into their own column, or even into separate TRUE/FALSE columns for each kind of sentinel. Note that sentinel values relate the the value in the cell, rather than to the whole row, so the first step is to make the dataset extra-tidy as in the section “Already a tidy table but with meaningful formatting of single cells”. # Tidy path &lt;- system.file(&quot;extdata&quot;, &quot;worked-examples.xlsx&quot;, package = &quot;unpivotr&quot;) x &lt;- read_excel(path, sheet = &quot;sentinels&quot;) x ## # A tibble: 4 x 3 ## Name Subject Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Matilda Music 7 ## 2 Nicholas Classics NA ## 3 Olivia … 3 ## 4 Paul NA ..C # Extra-tidy extra_tidy &lt;- gather(x, variable, value, -Name) %&gt;% arrange(Name, variable) extra_tidy ## # A tibble: 8 x 3 ## Name variable value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Matilda Score 7 ## 2 Matilda Subject Music ## 3 Nicholas Score NA ## 4 Nicholas Subject Classics ## 5 Olivia Score 3 ## 6 Olivia Subject … ## 7 Paul Score ..C ## 8 Paul Subject NA With an extra-tidy dataset, the sentinels can now be appended to the values of individual variables, rather than to whole observations. # Extra-tidy, with row and column numbers of the original variables, and the # sentinels omitted extra_tidy &lt;- read_excel(path, sheet = &quot;sentinels&quot;, na = c(&quot;NA&quot;, &quot;…&quot;, &quot;..C&quot;)) %&gt;% mutate(row = row_number() + 1L) %&gt;% gather(variable, value, -row, -Name) %&gt;% group_by(row) %&gt;% mutate(col = row_number() + 1L) %&gt;% ungroup() %&gt;% select(row, col, Name, variable, value) %&gt;% arrange(row, col) extra_tidy ## # A tibble: 8 x 5 ## row col Name variable value ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 2 Matilda Subject Music ## 2 2 3 Matilda Score 7 ## 3 3 2 Nicholas Subject Classics ## 4 3 3 Nicholas Score &lt;NA&gt; ## 5 4 2 Olivia Subject &lt;NA&gt; ## 6 4 3 Olivia Score 3 ## 7 5 2 Paul Subject &lt;NA&gt; ## 8 5 3 Paul Score &lt;NA&gt; # Import all the cells, and filter for sentinel values sentinels &lt;- xlsx_cells(path, sheet = &quot;sentinels&quot;) %&gt;% dplyr::filter(character %in% c(&quot;NA&quot;, &quot;…&quot;, &quot;..C&quot;)) %&gt;% mutate(sentinel = character) %&gt;% select(row, col, sentinel) sentinels ## # A tibble: 4 x 3 ## row col sentinel ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 3 3 NA ## 2 4 2 … ## 3 5 2 NA ## 4 5 3 ..C # Join the `sentinel` column to the rest of the data left_join(extra_tidy, sentinels, by = c(&quot;row&quot;, &quot;col&quot;)) ## # A tibble: 8 x 6 ## row col Name variable value sentinel ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 2 Matilda Subject Music &lt;NA&gt; ## 2 2 3 Matilda Score 7 &lt;NA&gt; ## 3 3 2 Nicholas Subject Classics &lt;NA&gt; ## 4 3 3 Nicholas Score &lt;NA&gt; NA ## 5 4 2 Olivia Subject &lt;NA&gt; … ## 6 4 3 Olivia Score 3 &lt;NA&gt; ## 7 5 2 Paul Subject &lt;NA&gt; NA ## 8 5 3 Paul Score &lt;NA&gt; ..C Here’s another version using only tidyxl and unpivotr, which provides isolate_sentinels() to make this much more straightforward. xlsx_cells(path, sheet = &quot;sentinels&quot;) %&gt;% select(row, col, data_type, character, numeric) %&gt;% isolate_sentinels(character, c(&quot;NA&quot;, &quot;…&quot;, &quot;..C&quot;)) %&gt;% behead(&quot;W&quot;, Name) %&gt;% behead(&quot;N&quot;, variable) %&gt;% select(Name, variable, character, numeric, sentinel) ## # A tibble: 8 x 5 ## Name variable character numeric sentinel ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Matilda Subject Music NA &lt;NA&gt; ## 2 Matilda Score &lt;NA&gt; 7 &lt;NA&gt; ## 3 Nicholas Subject Classics NA &lt;NA&gt; ## 4 Nicholas Score &lt;NA&gt; NA NA ## 5 Olivia Subject &lt;NA&gt; NA … ## 6 Olivia Score &lt;NA&gt; 3 &lt;NA&gt; ## 7 Paul Subject &lt;NA&gt; NA NA ## 8 Paul Score &lt;NA&gt; NA ..C "]
]
