<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Spreadsheet Munging Strategies</title>
  <meta name="description" content="Spreadsheet Munging Strategies">
  <meta name="generator" content="bookdown 0.7.4 and GitBook 2.6.7">

  <meta property="og:title" content="Spreadsheet Munging Strategies" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Spreadsheet Munging Strategies" />
  
  
  

<meta name="author" content="Duncan Garmonsway">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="tidy.html">
<link rel="next" href="pivot.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Welcome</a></li>
<li class="chapter" data-level="1" data-path="setup.html"><a href="setup.html"><i class="fa fa-check"></i><b>1</b> Setup</a><ul>
<li class="chapter" data-level="1.1" data-path="setup.html"><a href="setup.html#packages"><i class="fa fa-check"></i><b>1.1</b> Packages</a></li>
<li class="chapter" data-level="1.2" data-path="setup.html"><a href="setup.html#data"><i class="fa fa-check"></i><b>1.2</b> Data</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="tidy.html"><a href="tidy.html"><i class="fa fa-check"></i><b>2</b> Tidy tables with gotchas</a></li>
<li class="chapter" data-level="3" data-path="tidy-clean.html"><a href="tidy-clean.html"><i class="fa fa-check"></i><b>3</b> Clean, tidy tables</a><ul>
<li class="chapter" data-level="3.1" data-path="tidy-clean.html"><a href="tidy-clean.html#tidy-tables-with-gotchas"><i class="fa fa-check"></i><b>3.1</b> Tidy tables with gotchas</a><ul>
<li class="chapter" data-level="3.1.1" data-path="tidy-clean.html"><a href="tidy-clean.html#transposed-headers-in-the-first-row-data-extends-to-the-right"><i class="fa fa-check"></i><b>3.1.1</b> Transposed (headers in the first row, data extends to the right)</a></li>
<li class="chapter" data-level="3.1.2" data-path="tidy-clean.html"><a href="tidy-clean.html#other-stuff-on-the-same-sheet"><i class="fa fa-check"></i><b>3.1.2</b> Other stuff on the same sheet</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="tidy-clean.html"><a href="tidy-clean.html#tidy-formatted-rows"><i class="fa fa-check"></i><b>3.2</b> Meaningfully formatted rows</a></li>
<li class="chapter" data-level="3.3" data-path="tidy-clean.html"><a href="tidy-clean.html#tidy-formatted-cells"><i class="fa fa-check"></i><b>3.3</b> Meaningfully formatted cells</a></li>
<li class="chapter" data-level="3.4" data-path="tidy-clean.html"><a href="tidy-clean.html#layered-formatting"><i class="fa fa-check"></i><b>3.4</b> Layered meaningful formatting</a></li>
<li class="chapter" data-level="3.5" data-path="tidy-clean.html"><a href="tidy-clean.html#tidy-sentinel"><i class="fa fa-check"></i><b>3.5</b> Sentinel values in non-text columns</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="pivot.html"><a href="pivot.html"><i class="fa fa-check"></i><b>4</b> Pivot tables</a><ul>
<li class="chapter" data-level="4.1" data-path="pivot.html"><a href="pivot.html#pivot-simple"><i class="fa fa-check"></i><b>4.1</b> Simple unpivoting</a><ul>
<li class="chapter" data-level="4.1.1" data-path="pivot.html"><a href="pivot.html#two-clear-rows-of-text-column-headers-left-aligned"><i class="fa fa-check"></i><b>4.1.1</b> Two clear rows of text column headers, left-aligned</a></li>
<li class="chapter" data-level="4.1.2" data-path="pivot.html"><a href="pivot.html#two-clear-rows-and-columns-of-text-headers-top-aligned-and-left-aligned"><i class="fa fa-check"></i><b>4.1.2</b> Two clear rows and columns of text headers, top-aligned and left-aligned</a></li>
<li class="chapter" data-level="4.1.3" data-path="pivot.html"><a href="pivot.html#multiple-rows-or-columns-of-headers-with-meaningful-formatting"><i class="fa fa-check"></i><b>4.1.3</b> Multiple rows or columns of headers, with meaningful formatting</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="pivot.html"><a href="pivot.html#pivot-complex"><i class="fa fa-check"></i><b>4.2</b> Complex unpivoting</a><ul>
<li class="chapter" data-level="4.2.1" data-path="pivot.html"><a href="pivot.html#two-clear-rows-of-text-column-headers-left-aligned-2rl"><i class="fa fa-check"></i><b>4.2.1</b> Two clear rows of text column headers, left-aligned {#2RL}</a></li>
<li class="chapter" data-level="4.2.2" data-path="pivot.html"><a href="pivot.html#two-clear-columns-of-text-row-headers-top-aligned"><i class="fa fa-check"></i><b>4.2.2</b> Two clear columns of text row headers, top-aligned</a></li>
<li class="chapter" data-level="4.2.3" data-path="pivot.html"><a href="pivot.html#two-clear-rows-and-columns-of-text-headers-top-aligned-and-left-aligned-1"><i class="fa fa-check"></i><b>4.2.3</b> Two clear rows and columns of text headers, top-aligned and left-aligned</a></li>
<li class="chapter" data-level="4.2.4" data-path="pivot.html"><a href="pivot.html#centre-aligned-headers"><i class="fa fa-check"></i><b>4.2.4</b> Centre-aligned headers</a></li>
<li class="chapter" data-level="4.2.5" data-path="pivot.html"><a href="pivot.html#multiple-rows-or-columns-of-headers-with-meaningful-formatting-1"><i class="fa fa-check"></i><b>4.2.5</b> Multiple rows or columns of headers, with meaningful formatting</a></li>
<li class="chapter" data-level="4.2.6" data-path="pivot.html"><a href="pivot.html#mixed-headers-and-notes-in-the-same-rowcolumn-distinguished-by-formatting"><i class="fa fa-check"></i><b>4.2.6</b> Mixed headers and notes in the same row/column, distinguished by formatting</a></li>
<li class="chapter" data-level="4.2.7" data-path="pivot.html"><a href="pivot.html#mixed-levels-of-headers-in-the-same-rowcolumn-distinguished-by-formatting"><i class="fa fa-check"></i><b>4.2.7</b> Mixed levels of headers in the same row/column, distinguished by formatting</a></li>
<li class="chapter" data-level="4.2.8" data-path="pivot.html"><a href="pivot.html#repeated-rowscolumns-of-headers-within-the-table"><i class="fa fa-check"></i><b>4.2.8</b> Repeated rows/columns of headers within the table</a></li>
<li class="chapter" data-level="4.2.9" data-path="pivot.html"><a href="pivot.html#headers-amongst-the-data"><i class="fa fa-check"></i><b>4.2.9</b> Headers amongst the data</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="small-multiples.html"><a href="small-multiples.html"><i class="fa fa-check"></i><b>5</b> Small multiples</a><ul>
<li class="chapter" data-level="5.1" data-path="small-multiples.html"><a href="small-multiples.html#small-multiples-with-all-headers-present-for-each-multiple"><i class="fa fa-check"></i><b>5.1</b> Small multiples with all headers present for each multiple</a></li>
<li class="chapter" data-level="5.2" data-path="small-multiples.html"><a href="small-multiples.html#same-table-in-several-worksheetsfiles-using-the-sheetfile-name"><i class="fa fa-check"></i><b>5.2</b> Same table in several worksheets/files (using the sheet/file name)</a></li>
<li class="chapter" data-level="5.3" data-path="small-multiples.html"><a href="small-multiples.html#same-table-in-several-worksheetsfiles-but-in-different-positions"><i class="fa fa-check"></i><b>5.3</b> Same table in several worksheets/files but in different positions</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="formatting.html"><a href="formatting.html"><i class="fa fa-check"></i><b>6</b> Formatting</a><ul>
<li class="chapter" data-level="6.1" data-path="formatting.html"><a href="formatting.html#an-example-formatting-lookup"><i class="fa fa-check"></i><b>6.1</b> An example formatting lookup</a></li>
<li class="chapter" data-level="6.2" data-path="formatting.html"><a href="formatting.html#common-formats"><i class="fa fa-check"></i><b>6.2</b> Common formats</a></li>
<li class="chapter" data-level="6.3" data-path="formatting.html"><a href="formatting.html#in-cell-formatting"><i class="fa fa-check"></i><b>6.3</b> In-cell formatting</a></li>
<li class="chapter" data-level="6.4" data-path="formatting.html"><a href="formatting.html#multiple-pieces-of-information-in-a-single-cell-with-meaningful-formatting"><i class="fa fa-check"></i><b>6.4</b> Multiple pieces of information in a single cell, with meaningful formatting</a></li>
<li class="chapter" data-level="6.5" data-path="formatting.html"><a href="formatting.html#superscript-symbols"><i class="fa fa-check"></i><b>6.5</b> Superscript symbols</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="data-validation.html"><a href="data-validation.html"><i class="fa fa-check"></i><b>7</b> Data validation</a></li>
<li class="chapter" data-level="8" data-path="formulas.html"><a href="formulas.html"><i class="fa fa-check"></i><b>8</b> Formulas</a></li>
<li class="chapter" data-level="9" data-path="other-gotchas.html"><a href="other-gotchas.html"><i class="fa fa-check"></i><b>9</b> Other gotchas</a><ul>
<li class="chapter" data-level="9.1" data-path="other-gotchas.html"><a href="other-gotchas.html#non-text-headers-e.g.dates"><i class="fa fa-check"></i><b>9.1</b> Non-text headers e.g. dates</a></li>
<li class="chapter" data-level="9.2" data-path="other-gotchas.html"><a href="other-gotchas.html#data-embedded-in-comments"><i class="fa fa-check"></i><b>9.2</b> Data embedded in comments</a></li>
<li class="chapter" data-level="9.3" data-path="other-gotchas.html"><a href="other-gotchas.html#named-ranges"><i class="fa fa-check"></i><b>9.3</b> Named ranges</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Spreadsheet Munging Strategies</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="tidy-clean" class="section level1">
<h1><span class="header-section-number">3</span> Clean, tidy tables</h1>
<p>If the tables in the spreadsheet are clean and tidy, then you should use a
package like <a href="https://github.com/tidyverse/readxl">readxl</a>. But it’s worth
knowing how to emulate readxl with tidyxl and unpivotr, because some <em>almost</em>
clean tables can be handled using this technique.</p>
<p>Clean and tidy means</p>
<ul>
<li>One table per sheet</li>
<li>A single row of column headers, or no headers</li>
<li>A single data type in each column</li>
<li>Only one kind of sentinel value (to be interpreted as <code>NA</code>)</li>
<li>No meaningful formatting</li>
<li>No data buried in formulas</li>
<li>No need to refer to named ranges</li>
</ul>
<p>Here’s the full process.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;clean&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">behead</span>(<span class="st">&quot;N&quot;</span>, header) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, data_type, header, character, numeric) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">spatter</span>(header) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>row)</code></pre>
<pre><code>## # A tibble: 3 x 2
##     Age Name    
##   &lt;dbl&gt; &lt;chr&gt;   
## 1    1. Matilda 
## 2    3. Nicholas
## 3    5. Olivia</code></pre>
<p><code>tidyxl::xlsx_cells()</code> imports the spreadsheet into a data frame, where each row
of the data frame describes one cell of the spreadsheet. The columns <code>row</code> and
<code>col</code> (and <code>address</code>) describe the position of the cell, and the value of the
cell is in one of the columns <code>error</code>, <code>logical</code>, <code>numeric</code>, <code>date</code>,
<code>character</code>, depending on the type of data in the cell. The column <code>data_type</code>
says which column the value is in. Other columns describe formatting and
formulas.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;clean&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col, data_type, character, numeric)</code></pre>
<pre><code>## # A tibble: 8 x 5
##     row   col data_type character numeric
##   &lt;int&gt; &lt;int&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;
## 1     1     1 character Name          NA 
## 2     1     2 character Age           NA 
## 3     2     1 character Matilda       NA 
## 4     2     2 numeric   &lt;NA&gt;           1.
## 5     3     1 character Nicholas      NA 
## 6     3     2 numeric   &lt;NA&gt;           3.
## 7     4     1 character Olivia        NA 
## 8     4     2 numeric   &lt;NA&gt;           5.</code></pre>
<p><code>unpivotr::behead()</code> takes one level of headers from a pivot table and makes it
part of the data. Think of it like <code>tidyr::gather()</code>, except that it works when
there is more than one row of headers (or more than one column of row-headers),
and it only works on tables that have first come through
<code>unpivotr::tidy_table()</code> or <code>tidyxl::xlsx_cells()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;clean&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col, data_type, character, numeric) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">behead</span>(<span class="st">&quot;N&quot;</span>, header)</code></pre>
<pre><code>## # A tibble: 6 x 6
##     row   col data_type character numeric header
##   &lt;int&gt; &lt;int&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt; 
## 1     2     1 character Matilda       NA  Name  
## 2     2     2 numeric   &lt;NA&gt;           1. Age   
## 3     3     1 character Nicholas      NA  Name  
## 4     3     2 numeric   &lt;NA&gt;           3. Age   
## 5     4     1 character Olivia        NA  Name  
## 6     4     2 numeric   &lt;NA&gt;           5. Age</code></pre>
<p><code>unpivotr::spatter()</code> spreads key-value pairs across multiple columns, like
<code>tidyxl::spread()</code>, except that it handles mixed data types. It knows which
column contains the cell value (i.e. the <code>character</code> column or the <code>numeric</code>
column), by checking the <code>data_type</code> column. Just like <code>tidyr::spread()</code>, it
can be confused by extraneous data, so it’s usually a good idea to drop the
<code>col</code> column first, and to keep the <code>row</code> column.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;clean&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col, data_type, character, numeric) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">behead</span>(<span class="st">&quot;N&quot;</span>, header) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>col) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">spatter</span>(header) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>row)</code></pre>
<pre><code>## # A tibble: 3 x 2
##     Age Name    
##   &lt;dbl&gt; &lt;chr&gt;   
## 1    1. Matilda 
## 2    3. Nicholas
## 3    5. Olivia</code></pre>
<p>In case the table has no column headers, you can spatter the <code>col</code> column
instead of a nonexistent <code>header</code> column.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;clean&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(row <span class="op">&gt;=</span><span class="st"> </span><span class="dv">2</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col, data_type, character, numeric) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">spatter</span>(col) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>row)</code></pre>
<pre><code>## # A tibble: 3 x 2
##   `1`        `2`
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 Matilda     1.
## 2 Nicholas    3.
## 3 Olivia      5.</code></pre>
<p>Tidyxl and unpivotr are much more complicated than readxl, and that’s the point:
tidyxl and unpivotr give you more power and complexity when you need it.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_excel</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;clean&quot;</span>)</code></pre>
<pre><code>## # A tibble: 3 x 2
##   Name       Age
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 Matilda     1.
## 2 Nicholas    3.
## 3 Olivia      5.</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_excel</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;clean&quot;</span>, <span class="dt">col_names =</span> <span class="ot">FALSE</span>, <span class="dt">skip =</span> <span class="dv">1</span>)</code></pre>
<pre><code>## # A tibble: 3 x 2
##   X__1      X__2
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 Matilda     1.
## 2 Nicholas    3.
## 3 Olivia      5.</code></pre>

<div id="tidy-tables-with-gotchas" class="section level2">
<h2><span class="header-section-number">3.1</span> Tidy tables with gotchas</h2>
<p>For tables that are already ‘tidy’ (a single row of column headers), use
packages like <a href="http://readxl.tidyverse.org">readxl</a> that specialise in importing
tidy data.</p>
<p>But even with tidy tables, there can be gotchas.</p>
<div id="transposed-headers-in-the-first-row-data-extends-to-the-right" class="section level3">
<h3><span class="header-section-number">3.1.1</span> Transposed (headers in the first row, data extends to the right)</h3>
<p>Most packages for importing data assume that the headers are in the first row,
and each row of data is an observation. They usually don’t support the
alternative: headers in the first column, and each column of data is an
observation.</p>
<p>You can hack a way around this by importing without recognising any headers,
transposing with <code>t()</code> (which outputs a matrix), placing the headers as names,
and converting back to a data frame, but this almost always results in all the
data types being converted.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_excel</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;transposed&quot;</span>, <span class="dt">col_names =</span> <span class="ot">FALSE</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">t</span>() <span class="op">%&gt;%</span>
<span class="st">  `</span><span class="dt">colnames&lt;-</span><span class="st">`</span>(.[<span class="dv">1</span>, ]) <span class="op">%&gt;%</span>
<span class="st">  </span>.[<span class="op">-</span><span class="dv">1</span>, ] <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">as_tibble</span>()</code></pre>
<pre><code>## # A tibble: 3 x 2
##   Name     Age  
##   &lt;chr&gt;    &lt;chr&gt;
## 1 Matilda  1    
## 2 Nicholas 3    
## 3 Olivia   5</code></pre>
<p>Tidyxl and unpivotr are agnostic to the layout of tables. Importing the
transpose is the same is importing the usual layout, merely using the <code>&quot;W&quot;</code>
(west) direction instead of <code>&quot;N&quot;</code> (north) when beheading the headers.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;transposed&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">behead</span>(<span class="st">&quot;W&quot;</span>, header) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(col, data_type, header, character, numeric) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">spatter</span>(header) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(Name, Age)</code></pre>
<pre><code>## # A tibble: 3 x 2
##   Name       Age
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 Matilda     1.
## 2 Nicholas    3.
## 3 Olivia      5.</code></pre>
</div>
<div id="other-stuff-on-the-same-sheet" class="section level3">
<h3><span class="header-section-number">3.1.2</span> Other stuff on the same sheet</h3>
<p>It will be more complicated when the table doesn’t begin in cell A1, or if there
are non-blank cells above, below or either side of the table.</p>
<p>If you know at coding time which rows and columns the table occupies, then you
can do the following.</p>
<ul>
<li>Blank or non-blank cells above the table: use the <code>skip</code> argument of
<code>readxl::read_excel()</code>.</li>
<li>Blank or non-blank cells either side of the table: use the <code>col_types</code>
argument of <code>readxl::read_excel()</code> to ignore those columns.</li>
<li>Blank or non-blank cells below the table: use <code>n_max</code>
argument of <code>readxl::read_excel()</code> to ignore those rows.</li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r">readxl<span class="op">::</span><span class="kw">read_excel</span>(path,
                   <span class="dt">sheet =</span> <span class="st">&quot;notes&quot;</span>,
                   <span class="dt">skip =</span> <span class="dv">2</span>,
                   <span class="dt">n_max =</span> <span class="dv">33</span>,
                   <span class="dt">col_types =</span> <span class="kw">c</span>(<span class="st">&quot;guess&quot;</span>, <span class="st">&quot;guess&quot;</span>, <span class="st">&quot;skip&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">drop_na</span>()</code></pre>
<pre><code>## # A tibble: 2 x 2
##   Name       Age
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 Matilda     1.
## 2 Nicholas    3.</code></pre>
<p>If you don’t know at coding time which rows and columns the table occupies (
e.g. when the latest version of the spreadsheet is published and the table has
moved), then one strategy is to read the spreadsheet with <code>tidyxl::xlsx_cells()</code>
first, and inspect the results to determine the boundaries of the table. Then
use those boundaries as the <code>skip</code>, <code>n_max</code> and <code>col_types</code> arguments to
<code>readxl::read_excel()</code></p>
<ol style="list-style-type: decimal">
<li>Read the spreadsheet with <code>tidyxl::xlsx_cells()</code>. Filter the result for
sentinel values, e.g. the cells containing the first and final column
headers, and a cell in the final row of data.</li>
<li>Construct the arguments <code>skip</code>, <code>n_max</code> and <code>col_types</code> so that
<code>readxl::read_excel()</code> gets the exact dimensions of the table.</li>
</ol>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Step 1: read the spreadsheet and filter for sentinel values to detect the</span>
<span class="co"># top-left and bottom-right cells</span>
cells &lt;-<span class="st"> </span><span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;notes&quot;</span>)
<span class="kw">rectify</span>(cells)</code></pre>
<pre><code>## # A tibble: 7 x 5
##   `row/col` `1(A)`     `2(B)`   `3(C)` `4(D)`  
##       &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;   
## 1         1 Title text &lt;NA&gt;     &lt;NA&gt;   &lt;NA&gt;    
## 2         2 &lt;NA&gt;       &lt;NA&gt;     &lt;NA&gt;   &lt;NA&gt;    
## 3         3 &lt;NA&gt;       Name     Age    &lt;NA&gt;    
## 4         4 &lt;NA&gt;       Matilda  1      &lt;NA&gt;    
## 5         5 &lt;NA&gt;       Nicholas 3      &lt;NA&gt;    
## 6         6 &lt;NA&gt;       &lt;NA&gt;     &lt;NA&gt;   &lt;NA&gt;    
## 7         7 &lt;NA&gt;       &lt;NA&gt;     &lt;NA&gt;   Footnote</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">top_left &lt;-
<span class="st">  </span><span class="kw">filter</span>(cells, character <span class="op">==</span><span class="st"> &quot;Name&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col)
top_left</code></pre>
<pre><code>## # A tibble: 1 x 2
##     row   col
##   &lt;int&gt; &lt;int&gt;
## 1     3     2</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># It can be tricky to find the bottom-right cell because you have to make some</span>
<span class="co"># assumptions.  Here we assume that only cells within the table are numeric.</span>
bottom_right &lt;-
<span class="st">  </span><span class="kw">filter</span>(cells, data_type <span class="op">==</span><span class="st"> &quot;numeric&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">row =</span> <span class="kw">max</span>(row), <span class="dt">col =</span> <span class="kw">max</span>(col))
bottom_right</code></pre>
<pre><code>## # A tibble: 1 x 2
##     row   col
##   &lt;dbl&gt; &lt;dbl&gt;
## 1    5.    3.</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Step 2: construct the arguments `skip` and `n_max` for read_excel()</span>
skip &lt;-<span class="st"> </span>top_left<span class="op">$</span>row <span class="op">-</span><span class="st"> </span>1L
n_rows &lt;-<span class="st"> </span>bottom_right<span class="op">$</span>row <span class="op">-</span><span class="st"> </span>skip

<span class="kw">read_excel</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;notes&quot;</span>, <span class="dt">skip =</span> skip, <span class="dt">n_max =</span> n_rows)</code></pre>
<pre><code>## # A tibble: 2 x 2
##   Name       Age
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 Matilda     1.
## 2 Nicholas    3.</code></pre>
<p>Here’s another way using only tidyxl and unpivotr.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Step 2: filter for cells between the top-left and bottom-right, and spatter</span>
<span class="co"># into a table</span>
cells <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(<span class="kw">between</span>(row, top_left<span class="op">$</span>row, bottom_right<span class="op">$</span>row),
         <span class="kw">between</span>(col, top_left<span class="op">$</span>col, bottom_right<span class="op">$</span>col)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col, data_type, character, numeric) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">behead</span>(<span class="st">&quot;N&quot;</span>, header) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>col) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">spatter</span>(header) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>row)</code></pre>
<pre><code>## # A tibble: 2 x 2
##     Age Name    
##   &lt;dbl&gt; &lt;chr&gt;   
## 1    1. Matilda 
## 2    3. Nicholas</code></pre>

</div>
</div>
<div id="tidy-formatted-rows" class="section level2">
<h2><span class="header-section-number">3.2</span> Meaningfully formatted rows</h2>
<p>As with <a href="clean">clean, tidy tables</a>, but with a second step to interpret the
formatting.</p>
<p>Sometimes whole rows in a table are highlighted by formatting them with, say, a
bright yellow fill. The highlighting could mean “this observation should be
ignored”, or “this product is no longer available”. Different colours could
mean different levels of a hierarchy, e.g. green for “pass” and red for “fail”.</p>
<p>There are three steps to interpreting this.</p>
<ol style="list-style-type: decimal">
<li>Import the table, taking only the cell values and ignoring the formatting.</li>
<li>Import one column of the table, taking only the formatting and not the cell
values.</li>
<li>Use <code>dplyr::bind_cols()</code> to append the column of formatting to the table of
cell values. You can then interpret the formatting however you like.</li>
</ol>
<p>Step 1 is the same as <a href="clean">clean, tidy tables</a>.</p>
<p>Step 2 uses <code>tidyxl::xlsx_cells()</code> to load the data, <code>tidyxl::xlsx_formats()</code>,
and several tidyverse functions to link the two and filter for only one column.
Why only one column? Because if a whole row is highlighted, then you only need
to know the highlighting of one column to know the highlighting of all the
others.</p>
<p>This is a special case of the following section, <a href="tidy-formatted-cells">meaninfully formatted
cells</a>. Here <code>dplyr::bind_cols()</code> can be used as a
shortcut, because we are joining exactly <code>n</code> rows of formatting to <code>n</code> rows of
data. The following sections is a more general case that can be used instead of
this procedure.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Step 1: import the table taking only cell values and ignoring the formatting</span>
x &lt;-<span class="st"> </span><span class="kw">read_excel</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;highlights&quot;</span>)

<span class="co"># Step 2: import one column of the table, taking only the formatting and not the</span>
<span class="co"># cell values</span>

<span class="co"># `formats` is a pallette of fill colours that can be indexed by the</span>
<span class="co"># `local_format_id` of a given cell to get the fill colour of that cell</span>
fill_colours &lt;-<span class="st"> </span><span class="kw">xlsx_formats</span>(path)<span class="op">$</span>local<span class="op">$</span>fill<span class="op">$</span>patternFill<span class="op">$</span>fgColor<span class="op">$</span>rgb

<span class="co"># Import all the cells, filter out the header row, filter for the first column,</span>
<span class="co"># and create a new column `fill_colour` of the fill colours, by looking up the</span>
<span class="co"># local_format_id of each cell in the `fill_colours` pallette.</span>
fills &lt;-
<span class="st">  </span><span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;highlights&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(row <span class="op">&gt;=</span><span class="st"> </span><span class="dv">2</span>, col <span class="op">==</span><span class="st"> </span><span class="dv">1</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># Omit the header row</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">fill_colour =</span> fill_colours[local_format_id]) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(fill_colour)

<span class="co"># Step 3: append the `fill` column to the rest of the data</span>
<span class="kw">bind_cols</span>(x, fills) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(Age, Height, fill_colour)</code></pre>
<pre><code>## # A tibble: 3 x 3
##     Age Height fill_colour
##   &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;      
## 1    1.     2. &lt;NA&gt;       
## 2    3.     4. FFFFFF00   
## 3    5.     6. &lt;NA&gt;</code></pre>
<p>Note that the fill colour is expressed as an RGB value with transparency in the
first two letters, e.g. <code>FFFFFF00</code> is <code>FF</code> (opaque), with <code>FFFF00</code> (yellow).</p>
<p>Here’s another way using only tidyxl and unpivotr.</p>
<pre class="sourceCode r"><code class="sourceCode r">fill_colours &lt;-<span class="st"> </span><span class="kw">xlsx_formats</span>(path)<span class="op">$</span>local<span class="op">$</span>fill<span class="op">$</span>patternFill<span class="op">$</span>fgColor<span class="op">$</span>rgb

<span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;highlights&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">fill_colour =</span> fill_colours[local_format_id]) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col, data_type, character, numeric, fill_colour) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">behead</span>(<span class="st">&quot;N&quot;</span>, header) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>col, <span class="op">-</span>character) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">spatter</span>(header) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>row)</code></pre>
<pre><code>## # A tibble: 3 x 3
##   fill_colour   Age Height
##   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;
## 1 &lt;NA&gt;           1.     2.
## 2 FFFFFF00       3.     4.
## 3 &lt;NA&gt;           5.     6.</code></pre>

</div>
<div id="tidy-formatted-cells" class="section level2">
<h2><span class="header-section-number">3.3</span> Meaningfully formatted cells</h2>
<p>If single cells are highlighted, rather than whole rows, then the highlights
probably indicate something about the column rather than the row. For example,
a highlighted cell in a column called “age” of a table of medical patients,
might mean “the age of this patient is uncertain”.</p>
<p>One way to deal with this is to create a new column in the final table for each
column in the original that has any highlighted cells. For example, if
highlighted cells mean “this value is uncertain”, and some cells in the <code>age</code>
and <code>height</code> columns are highlighted, then you could create two new columns:
<code>uncertain_age</code>, and <code>uncertain_height</code>, by following the procedure of
<a href="tidy-formatted-rows">meaningfully formatteed rows</a> for each column <code>age</code> and
<code>height</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Step 1: import the table taking only cell values and ignoring the formatting</span>
x &lt;-<span class="st"> </span><span class="kw">read_excel</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;annotations&quot;</span>)

<span class="co"># Step 2: import one column of the table, taking only the formatting and not the</span>
<span class="co"># cell values</span>

<span class="co"># `formats` is a pallette of fill colours that can be indexed by the</span>
<span class="co"># `local_format_id` of a given cell to get the fill colour of that cell</span>
fill_colours &lt;-<span class="st"> </span><span class="kw">xlsx_formats</span>(path)<span class="op">$</span>local<span class="op">$</span>fill<span class="op">$</span>patternFill<span class="op">$</span>fgColor<span class="op">$</span>rgb

<span class="co"># Import all the cells, filter out the header row, filter for the first column,</span>
<span class="co"># and create new columns `something_fill` of the fill colours, by looking up the</span>
<span class="co"># local_format_id of each cell in the `formats` pallette.</span>
fills &lt;-
<span class="st">  </span><span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;annotations&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(row <span class="op">&gt;=</span><span class="st"> </span><span class="dv">2</span>, col <span class="op">&gt;=</span><span class="st"> </span><span class="dv">2</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># Omit the header row and name column</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">fill_colour =</span> fill_colours[local_format_id]) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col, fill_colour) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">spread</span>(col, fill_colour) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>row) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">set_names</span>(<span class="kw">paste0</span>(<span class="kw">colnames</span>(x)[<span class="op">-</span><span class="dv">1</span>], <span class="st">&quot;_fill&quot;</span>))
fills</code></pre>
<pre><code>## # A tibble: 3 x 2
##   Age_fill Height_fill
##   &lt;chr&gt;    &lt;chr&gt;      
## 1 &lt;NA&gt;     &lt;NA&gt;       
## 2 FFFFFF00 &lt;NA&gt;       
## 3 &lt;NA&gt;     FF92D050</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Step 3: append the `fill` column to the rest of the data</span>
<span class="kw">bind_cols</span>(x, fills)</code></pre>
<pre><code>## # A tibble: 3 x 5
##   Name       Age Height Age_fill Height_fill
##   &lt;chr&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;      
## 1 Matilda     1.     2. &lt;NA&gt;     &lt;NA&gt;       
## 2 Nicholas    3.     4. FFFFFF00 &lt;NA&gt;       
## 3 Olivia      5.     6. &lt;NA&gt;     FF92D050</code></pre>
<p>Here’s the same thing, but using only tidyxl and unpivotr</p>
<pre class="sourceCode r"><code class="sourceCode r">fill_colours &lt;-<span class="st"> </span><span class="kw">xlsx_formats</span>(path)<span class="op">$</span>local<span class="op">$</span>fill<span class="op">$</span>patternFill<span class="op">$</span>fgColor<span class="op">$</span>rgb

cells &lt;-
<span class="st">  </span><span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;annotations&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">fill_colour =</span> fill_colours[local_format_id]) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col, data_type, character, numeric, fill_colour)
cells</code></pre>
<pre><code>## # A tibble: 12 x 6
##      row   col data_type character numeric fill_colour
##    &lt;int&gt; &lt;int&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;      
##  1     1     1 character Name          NA  &lt;NA&gt;       
##  2     1     2 character Age           NA  &lt;NA&gt;       
##  3     1     3 character Height        NA  &lt;NA&gt;       
##  4     2     1 character Matilda       NA  &lt;NA&gt;       
##  5     2     2 numeric   &lt;NA&gt;           1. &lt;NA&gt;       
##  6     2     3 numeric   &lt;NA&gt;           2. &lt;NA&gt;       
##  7     3     1 character Nicholas      NA  &lt;NA&gt;       
##  8     3     2 numeric   &lt;NA&gt;           3. FFFFFF00   
##  9     3     3 numeric   &lt;NA&gt;           4. &lt;NA&gt;       
## 10     4     1 character Olivia        NA  &lt;NA&gt;       
## 11     4     2 numeric   &lt;NA&gt;           5. &lt;NA&gt;       
## 12     4     3 numeric   &lt;NA&gt;           6. FF92D050</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">values &lt;-
<span class="st">  </span>cells <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>fill_colour) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">behead</span>(<span class="st">&quot;N&quot;</span>, header) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>col) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">spatter</span>(header)
values</code></pre>
<pre><code>## # A tibble: 3 x 4
##     row   Age Height Name    
##   &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;   
## 1     2    1.     2. Matilda 
## 2     3    3.     4. Nicholas
## 3     4    5.     6. Olivia</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">fills &lt;-
<span class="st">  </span>cells <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">behead</span>(<span class="st">&quot;N&quot;</span>, header) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">header =</span> <span class="kw">paste0</span>(header, <span class="st">&quot;_fill&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, header, fill_colour) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">spread</span>(header, fill_colour)
fills</code></pre>
<pre><code>## # A tibble: 3 x 4
##     row Age_fill Height_fill Name_fill
##   &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;       &lt;chr&gt;    
## 1     2 &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;     
## 2     3 FFFFFF00 &lt;NA&gt;        &lt;NA&gt;     
## 3     4 &lt;NA&gt;     FF92D050    &lt;NA&gt;</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">left_join</span>(values, fills, <span class="dt">by =</span> <span class="st">&quot;row&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>row)</code></pre>
<pre><code>## # A tibble: 3 x 6
##     Age Height Name     Age_fill Height_fill Name_fill
##   &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;       &lt;chr&gt;    
## 1    1.     2. Matilda  &lt;NA&gt;     &lt;NA&gt;        &lt;NA&gt;     
## 2    3.     4. Nicholas FFFFFF00 &lt;NA&gt;        &lt;NA&gt;     
## 3    5.     6. Olivia   &lt;NA&gt;     FF92D050    &lt;NA&gt;</code></pre>
<p>Another way would be to make the table what I call “extra-tidy”. If it is tidy,
then each row is an observation, and each column is a variable. To make it
“extra-tidy”, you <code>gather()</code> the variables so that each row is <em>one observation
of one variable</em>. This works best when every variable has the same data type,
otherwise the values will be coerced, probably to a character.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Tidy</span>
(x &lt;-<span class="st"> </span><span class="kw">read_excel</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;annotations&quot;</span>))</code></pre>
<pre><code>## # A tibble: 3 x 3
##   Name       Age Height
##   &lt;chr&gt;    &lt;dbl&gt;  &lt;dbl&gt;
## 1 Matilda     1.     2.
## 2 Nicholas    3.     4.
## 3 Olivia      5.     6.</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Extra-tidy</span>
extra_tidy &lt;-
<span class="st">  </span>x <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">gather</span>(variable, value, <span class="op">-</span>Name) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">arrange</span>(Name, variable)
extra_tidy</code></pre>
<pre><code>## # A tibble: 6 x 3
##   Name     variable value
##   &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt;
## 1 Matilda  Age         1.
## 2 Matilda  Height      2.
## 3 Nicholas Age         3.
## 4 Nicholas Height      4.
## 5 Olivia   Age         5.
## 6 Olivia   Height      6.</code></pre>
<p>With an extra-tidy dataset, the formatting can now be appended to the values of
individual variables, rather than to whole observations.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Extra-tidy, with row and column numbers of the original variables</span>
extra_tidy &lt;-
<span class="st">  </span><span class="kw">read_excel</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;annotations&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">row =</span> <span class="kw">row_number</span>() <span class="op">+</span><span class="st"> </span>1L) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">gather</span>(variable, value, <span class="op">-</span>row, <span class="op">-</span>Name) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">group_by</span>(row) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">col =</span> <span class="kw">row_number</span>() <span class="op">+</span><span class="st"> </span>1L) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ungroup</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col, Name, variable, value) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">arrange</span>(row, col)
extra_tidy</code></pre>
<pre><code>## # A tibble: 6 x 5
##     row   col Name     variable value
##   &lt;int&gt; &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt;
## 1     2     2 Matilda  Age         1.
## 2     2     3 Matilda  Height      2.
## 3     3     2 Nicholas Age         3.
## 4     3     3 Nicholas Height      4.
## 5     4     2 Olivia   Age         5.
## 6     4     3 Olivia   Height      6.</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># `formats` is a pallette of fill colours that can be indexed by the</span>
<span class="co"># `local_format_id` of a given cell to get the fill colour of that cell</span>
fill_colours &lt;-<span class="st"> </span><span class="kw">xlsx_formats</span>(path)<span class="op">$</span>local<span class="op">$</span>fill<span class="op">$</span>patternFill<span class="op">$</span>fgColor<span class="op">$</span>rgb

<span class="co"># Import all the cells, filter out the header row, filter for the first column,</span>
<span class="co"># and create a new column `uncertain` based on the fill colours, by looking up</span>
<span class="co"># the local_format_id of each cell in the `formats` pallette.</span>
fills &lt;-
<span class="st">  </span><span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;annotations&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(row <span class="op">&gt;=</span><span class="st"> </span><span class="dv">2</span>, col <span class="op">&gt;=</span><span class="st"> </span><span class="dv">2</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># Omit the header row and name column</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">fill_colour =</span> fill_colours[local_format_id]) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col, fill_colour)
fills</code></pre>
<pre><code>## # A tibble: 6 x 3
##     row   col fill_colour
##   &lt;int&gt; &lt;int&gt; &lt;chr&gt;      
## 1     2     2 &lt;NA&gt;       
## 2     2     3 &lt;NA&gt;       
## 3     3     2 FFFFFF00   
## 4     3     3 &lt;NA&gt;       
## 5     4     2 &lt;NA&gt;       
## 6     4     3 FF92D050</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Step 3: append the `fill` column to the rest of the data</span>
<span class="kw">left_join</span>(extra_tidy, fills, <span class="dt">by =</span> <span class="kw">c</span>(<span class="st">&quot;row&quot;</span>, <span class="st">&quot;col&quot;</span>))</code></pre>
<pre><code>## # A tibble: 6 x 6
##     row   col Name     variable value fill_colour
##   &lt;int&gt; &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt;      
## 1     2     2 Matilda  Age         1. &lt;NA&gt;       
## 2     2     3 Matilda  Height      2. &lt;NA&gt;       
## 3     3     2 Nicholas Age         3. FFFFFF00   
## 4     3     3 Nicholas Height      4. &lt;NA&gt;       
## 5     4     2 Olivia   Age         5. &lt;NA&gt;       
## 6     4     3 Olivia   Height      6. FF92D050</code></pre>
<p>Here’s the same extra-tidy version, but using only tidyxl and unpivotr.</p>
<pre class="sourceCode r"><code class="sourceCode r">fill_colours &lt;-<span class="st"> </span><span class="kw">xlsx_formats</span>(path)<span class="op">$</span>local<span class="op">$</span>fill<span class="op">$</span>patternFill<span class="op">$</span>fgColor<span class="op">$</span>rgb

<span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;annotations&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">fill_colour =</span> fill_colours[local_format_id]) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col, data_type, character, numeric, fill_colour) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">behead</span>(<span class="st">&quot;W&quot;</span>, Name) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">behead</span>(<span class="st">&quot;N&quot;</span>, variable) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>data_type, <span class="op">-</span>character, <span class="dt">value =</span> numeric)</code></pre>
<pre><code>## # A tibble: 6 x 6
##     row   col value fill_colour Name     variable
##   &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;   
## 1     2     2    1. &lt;NA&gt;        Matilda  Age     
## 2     2     3    2. &lt;NA&gt;        Matilda  Height  
## 3     3     2    3. FFFFFF00    Nicholas Age     
## 4     3     3    4. &lt;NA&gt;        Nicholas Height  
## 5     4     2    5. &lt;NA&gt;        Olivia   Age     
## 6     4     3    6. FF92D050    Olivia   Height</code></pre>

</div>
<div id="layered-formatting" class="section level2">
<h2><span class="header-section-number">3.4</span> Layered meaningful formatting</h2>
<p>Sometimes different kinds of formatting relate to clearly different aspects of
an observation, e.g. yellow highlight for “uncertain data” and red text for
“product no longer available”. Both yellow highlighting and red text in the
same row would indicate uncertain data and unavailability of the product at the
same time.</p>
<p>Deal with it by reading each kind of formatting into a separate column,
e.g. fill colour into one column, font colour into another, bold/not-bold into a
another, etc.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Step 1: import the table taking only cell values and ignoring the formatting</span>
x &lt;-<span class="st"> </span><span class="kw">read_excel</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;combined-highlights&quot;</span>)

<span class="co"># Step 2: import one kind of formatting of one column of the table</span>

<span class="co"># `formats` is a pallette of fill colours that can be indexed by the</span>
<span class="co"># `local_format_id` of a given cell to get the fill colour of that cell</span>
fill_colours &lt;-<span class="st"> </span><span class="kw">xlsx_formats</span>(path)<span class="op">$</span>local<span class="op">$</span>fill<span class="op">$</span>patternFill<span class="op">$</span>fgColor<span class="op">$</span>rgb
font_colours &lt;-<span class="st"> </span><span class="kw">xlsx_formats</span>(path)<span class="op">$</span>local<span class="op">$</span>font<span class="op">$</span>color<span class="op">$</span>rgb

<span class="co"># Import all the cells, filter out the header row, filter for the first column,</span>
<span class="co"># and create a new column `fill` of the fill colours, by looking up the</span>
<span class="co"># local_format_id of each cell in the `formats` pallette.</span>
formats &lt;-
<span class="st">  </span><span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;combined-highlights&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(row <span class="op">&gt;=</span><span class="st"> </span><span class="dv">2</span>, col <span class="op">==</span><span class="st"> </span><span class="dv">1</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># Omit the header row</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">fill_colour =</span> fill_colours[local_format_id],
         <span class="dt">font_colour =</span> font_colours[local_format_id]) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(fill_colour, font_colour)

<span class="co"># Step 3: append the `fill` column to the rest of the data</span>
<span class="kw">bind_cols</span>(x, formats)</code></pre>
<pre><code>## # A tibble: 4 x 5
##   Name     Weight Price fill_colour font_colour
##   &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;      
## 1 Knife        7.    8. &lt;NA&gt;        FF000000   
## 2 Fork         5.    6. FFFFFF00    FF000000   
## 3 Spoon        3.    4. &lt;NA&gt;        FFFF0000   
## 4 Teaspoon     1.    2. FFFFFF00    FFFF0000</code></pre>
<p>Here’s the same thing, but using only tidyxl and unpivotr.</p>
<pre class="sourceCode r"><code class="sourceCode r">fill_colours &lt;-<span class="st"> </span><span class="kw">xlsx_formats</span>(path)<span class="op">$</span>local<span class="op">$</span>fill<span class="op">$</span>patternFill<span class="op">$</span>fgColor<span class="op">$</span>rgb
font_colours &lt;-<span class="st"> </span><span class="kw">xlsx_formats</span>(path)<span class="op">$</span>local<span class="op">$</span>font<span class="op">$</span>color<span class="op">$</span>rgb

cells &lt;-
<span class="st">  </span><span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;combined-highlights&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">fill_colour =</span> fill_colours[local_format_id],
         <span class="dt">font_colour =</span> font_colours[local_format_id]) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col, data_type, character, numeric, fill_colour, font_colour) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">behead</span>(<span class="st">&quot;N&quot;</span>, header) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">behead</span>(<span class="st">&quot;W&quot;</span>, Name) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>col, <span class="op">-</span>character)

values &lt;-
<span class="st">  </span>cells <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>fill_colour, <span class="op">-</span>font_colour) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">spread</span>(header, numeric)

formats &lt;-<span class="st"> </span><span class="kw">distinct</span>(cells, row, fill_colour, font_colour)

<span class="kw">left_join</span>(values, formats, <span class="dt">by =</span> <span class="st">&quot;row&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>row)</code></pre>
<pre><code>## # A tibble: 4 x 6
##   data_type Name     Price Weight fill_colour font_colour
##   &lt;chr&gt;     &lt;chr&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;      
## 1 numeric   Knife       8.     7. &lt;NA&gt;        FF000000   
## 2 numeric   Fork        6.     5. FFFFFF00    &lt;NA&gt;       
## 3 numeric   Spoon       4.     3. &lt;NA&gt;        FFFF0000   
## 4 numeric   Teaspoon    2.     1. FFFFFF00    FFFF0000</code></pre>
<p>Different kinds of formatting might also represent different levels of a
hierarchy, e.g.</p>
<table>
<thead>
<tr class="header">
<th align="left">formatting</th>
<th align="left">interpretation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">none</td>
<td align="left">good</td>
</tr>
<tr class="even">
<td align="left">italic</td>
<td align="left">satisfactory</td>
</tr>
<tr class="odd">
<td align="left">bold</td>
<td align="left">poor</td>
</tr>
<tr class="even">
<td align="left">bold &amp; italic</td>
<td align="left">fail</td>
</tr>
</tbody>
</table>
<p>When each kind of formatting relates to a different level of one hierarchy,
import the different kinds of formatting into different columns, and then
combine them into a third column, perhaps using <code>paste()</code>, or <code>case_when()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Step 1: import the table taking only cell values and ignoring the formatting</span>
x &lt;-<span class="st"> </span><span class="kw">read_excel</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;highlight-hierarchy&quot;</span>)
x</code></pre>
<pre><code>## # A tibble: 4 x 2
##   Name     Score
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 Matilda     7.
## 2 Nicholas    5.
## 3 Olivia      3.
## 4 Paul        1.</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Step 2: import one kind of formatting of one column of the table</span>

<span class="co"># `formats` is a pallette of fill colours that can be indexed by the</span>
<span class="co"># `local_format_id` of a given cell to get the fill colour of that cell</span>
bold &lt;-<span class="st"> </span><span class="kw">xlsx_formats</span>(path)<span class="op">$</span>local<span class="op">$</span>font<span class="op">$</span>bold
italic &lt;-<span class="st"> </span><span class="kw">xlsx_formats</span>(path)<span class="op">$</span>local<span class="op">$</span>font<span class="op">$</span>italic

<span class="co"># Import all the cells, filter out the header row, filter for the first column,</span>
<span class="co"># and create a new column `fill` of the fill colours, by looking up the</span>
<span class="co"># local_format_id of each cell in the `formats` pallette.</span>
formats &lt;-
<span class="st">  </span><span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;highlight-hierarchy&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(row <span class="op">&gt;=</span><span class="st"> </span><span class="dv">2</span>, col <span class="op">==</span><span class="st"> </span><span class="dv">1</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># Omit the header row</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">bold =</span> bold[local_format_id],
         <span class="dt">italic =</span> italic[local_format_id]) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">grade =</span> <span class="kw">case_when</span>(bold <span class="op">&amp;</span><span class="st"> </span>italic <span class="op">~</span><span class="st"> &quot;fail&quot;</span>,
                           bold <span class="op">~</span><span class="st"> &quot;poor&quot;</span>,
                           italic <span class="op">~</span><span class="st"> &quot;satisfactory&quot;</span>,
                           <span class="ot">TRUE</span> <span class="op">~</span><span class="st"> &quot;good&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(bold, italic, grade)

<span class="co"># Step 3: append the `fill` column to the rest of the data</span>
<span class="kw">bind_cols</span>(x, formats)</code></pre>
<pre><code>## # A tibble: 4 x 5
##   Name     Score bold  italic grade       
##   &lt;chr&gt;    &lt;dbl&gt; &lt;lgl&gt; &lt;lgl&gt;  &lt;chr&gt;       
## 1 Matilda     7. FALSE FALSE  good        
## 2 Nicholas    5. FALSE TRUE   satisfactory
## 3 Olivia      3. TRUE  FALSE  poor        
## 4 Paul        1. TRUE  TRUE   fail</code></pre>
<p>Here it is again, using only tidyxl and unpivotr.</p>
<pre class="sourceCode r"><code class="sourceCode r">bold &lt;-<span class="st"> </span><span class="kw">xlsx_formats</span>(path)<span class="op">$</span>local<span class="op">$</span>font<span class="op">$</span>bold
italic &lt;-<span class="st"> </span><span class="kw">xlsx_formats</span>(path)<span class="op">$</span>local<span class="op">$</span>font<span class="op">$</span>italic

<span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;highlight-hierarchy&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">bold =</span> bold[local_format_id],
         <span class="dt">italic =</span> italic[local_format_id]) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">grade =</span> <span class="kw">case_when</span>(bold <span class="op">&amp;</span><span class="st"> </span>italic <span class="op">~</span><span class="st"> &quot;fail&quot;</span>,
                           bold <span class="op">~</span><span class="st"> &quot;poor&quot;</span>,
                           italic <span class="op">~</span><span class="st"> &quot;satisfactory&quot;</span>,
                           <span class="ot">TRUE</span> <span class="op">~</span><span class="st"> &quot;good&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col, data_type, character, numeric, bold, italic, grade) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">behead</span>(<span class="st">&quot;N&quot;</span>, header) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>col) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">spatter</span>(header)</code></pre>
<pre><code>## # A tibble: 4 x 6
##     row bold  italic grade        Name     Score
##   &lt;int&gt; &lt;lgl&gt; &lt;lgl&gt;  &lt;chr&gt;        &lt;chr&gt;    &lt;dbl&gt;
## 1     2 FALSE FALSE  good         Matilda     7.
## 2     3 FALSE TRUE   satisfactory Nicholas    5.
## 3     4 TRUE  FALSE  poor         Olivia      3.
## 4     5 TRUE  TRUE   fail         Paul        1.</code></pre>

</div>
<div id="tidy-sentinel" class="section level2">
<h2><span class="header-section-number">3.5</span> Sentinel values in non-text columns</h2>
<p>R packages like <a href="http://readr.tidyverse.org/">readr</a> recognise <code>NA</code> as a
sentinel value that means “Not Applicable”, or “Not Available”, or anything you
want. It doesn’t affect the data type of a column when <code>NA</code> is one of the
values. Some datasets use other symbols as a sentinel value, e.g. <code>N/A</code> or <code>.</code>,
or a combination, in which case you can instruct <code>readr</code> to interpret those
values as sentinels, and it will import them all as <code>NA</code>.</p>
<p>But what if the data uses more than one <em>kind</em> of sentinel value. For example,
Statistics New Zealand uses <code>…</code> to mean “Not applicable”, and <code>..C</code> to mean
“Confidentialised”. Most tools will either regard both values as <code>NA</code>, or
coerce the whole column to characters.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;a, b,   c</span>
<span class="st">          1, 2,   3</span>
<span class="st">          4, …, ..C&quot;</span>,
         <span class="dt">na =</span> <span class="kw">c</span>(<span class="st">&quot;…&quot;</span>, <span class="st">&quot;..C&quot;</span>)) <span class="co"># Regard both values as NA</span></code></pre>
<pre><code>## # A tibble: 2 x 3
##       a     b     c
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1    1.    2.    3.
## 2    4.   NA    NA</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;a, b,   c</span>
<span class="st">          1, 2,   3</span>
<span class="st">          4, …, ..C&quot;</span>,
         <span class="dt">na =</span> <span class="st">&quot;&quot;</span>)              <span class="co"># Coerce the whole column to characters</span></code></pre>
<pre><code>## # A tibble: 2 x 3
##       a b     c    
##   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;
## 1    1. 2     3    
## 2    4. …     ..C</code></pre>
<p>A better procedure is to import the sentinel values into their own column, or
even into separate <code>TRUE</code>/<code>FALSE</code> columns for each kind of sentinel.</p>
<p>Note that sentinel values relate the the value in the cell, rather than to the
whole row, so the first step is to make the dataset <em>extra-tidy</em> as in the
section “Already a tidy table but with meaningful formatting of single cells”.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Tidy</span>
x &lt;-<span class="st"> </span><span class="kw">read_excel</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;sentinels&quot;</span>)
x</code></pre>
<pre><code>## # A tibble: 4 x 3
##   Name     Subject  Score
##   &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;
## 1 Matilda  Music    7    
## 2 Nicholas Classics NA   
## 3 Olivia   …        3    
## 4 Paul     NA       ..C</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Extra-tidy</span>
extra_tidy &lt;-
<span class="st">  </span><span class="kw">gather</span>(x, variable, value, <span class="op">-</span>Name) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">arrange</span>(Name, variable)
extra_tidy</code></pre>
<pre><code>## # A tibble: 8 x 3
##   Name     variable value   
##   &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   
## 1 Matilda  Score    7       
## 2 Matilda  Subject  Music   
## 3 Nicholas Score    NA      
## 4 Nicholas Subject  Classics
## 5 Olivia   Score    3       
## 6 Olivia   Subject  …       
## 7 Paul     Score    ..C     
## 8 Paul     Subject  NA</code></pre>
<p>With an extra-tidy dataset, the sentinels can now be appended to the values of
individual variables, rather than to whole observations.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Extra-tidy, with row and column numbers of the original variables, and the</span>
<span class="co"># sentinels omitted</span>
extra_tidy &lt;-
<span class="st">  </span><span class="kw">read_excel</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;sentinels&quot;</span>, <span class="dt">na =</span> <span class="kw">c</span>(<span class="st">&quot;NA&quot;</span>, <span class="st">&quot;…&quot;</span>, <span class="st">&quot;..C&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">row =</span> <span class="kw">row_number</span>() <span class="op">+</span><span class="st"> </span>1L) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">gather</span>(variable, value, <span class="op">-</span>row, <span class="op">-</span>Name) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">group_by</span>(row) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">col =</span> <span class="kw">row_number</span>() <span class="op">+</span><span class="st"> </span>1L) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ungroup</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col, Name, variable, value) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">arrange</span>(row, col)
extra_tidy</code></pre>
<pre><code>## # A tibble: 8 x 5
##     row   col Name     variable value   
##   &lt;int&gt; &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   
## 1     2     2 Matilda  Subject  Music   
## 2     2     3 Matilda  Score    7       
## 3     3     2 Nicholas Subject  Classics
## 4     3     3 Nicholas Score    &lt;NA&gt;    
## 5     4     2 Olivia   Subject  &lt;NA&gt;    
## 6     4     3 Olivia   Score    3       
## 7     5     2 Paul     Subject  &lt;NA&gt;    
## 8     5     3 Paul     Score    &lt;NA&gt;</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Import all the cells, and filter for sentinel values</span>
sentinels &lt;-
<span class="st">  </span><span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;sentinels&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(character <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;NA&quot;</span>, <span class="st">&quot;…&quot;</span>, <span class="st">&quot;..C&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">sentinel =</span> character) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col, sentinel)
sentinels</code></pre>
<pre><code>## # A tibble: 4 x 3
##     row   col sentinel
##   &lt;int&gt; &lt;int&gt; &lt;chr&gt;   
## 1     3     3 NA      
## 2     4     2 …       
## 3     5     2 NA      
## 4     5     3 ..C</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Join the `sentinel` column to the rest of the data</span>
<span class="kw">left_join</span>(extra_tidy, sentinels, <span class="dt">by =</span> <span class="kw">c</span>(<span class="st">&quot;row&quot;</span>, <span class="st">&quot;col&quot;</span>))</code></pre>
<pre><code>## # A tibble: 8 x 6
##     row   col Name     variable value    sentinel
##   &lt;int&gt; &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   
## 1     2     2 Matilda  Subject  Music    &lt;NA&gt;    
## 2     2     3 Matilda  Score    7        &lt;NA&gt;    
## 3     3     2 Nicholas Subject  Classics &lt;NA&gt;    
## 4     3     3 Nicholas Score    &lt;NA&gt;     NA      
## 5     4     2 Olivia   Subject  &lt;NA&gt;     …       
## 6     4     3 Olivia   Score    3        &lt;NA&gt;    
## 7     5     2 Paul     Subject  &lt;NA&gt;     NA      
## 8     5     3 Paul     Score    &lt;NA&gt;     ..C</code></pre>
<p>Here’s another version using only tidyxl and unpivotr, which provides
<code>isolate_sentinels()</code> to make this much more straightforward.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">xlsx_cells</span>(path, <span class="dt">sheet =</span> <span class="st">&quot;sentinels&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(row, col, data_type, character, numeric) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">isolate_sentinels</span>(character, <span class="kw">c</span>(<span class="st">&quot;NA&quot;</span>, <span class="st">&quot;…&quot;</span>, <span class="st">&quot;..C&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">behead</span>(<span class="st">&quot;W&quot;</span>, Name) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">behead</span>(<span class="st">&quot;N&quot;</span>, variable) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(Name, variable, character, numeric, sentinel)</code></pre>
<pre><code>## # A tibble: 8 x 5
##   Name     variable character numeric sentinel
##   &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;   
## 1 Matilda  Subject  Music         NA  &lt;NA&gt;    
## 2 Matilda  Score    &lt;NA&gt;           7. &lt;NA&gt;    
## 3 Nicholas Subject  Classics      NA  &lt;NA&gt;    
## 4 Nicholas Score    &lt;NA&gt;          NA  NA      
## 5 Olivia   Subject  &lt;NA&gt;          NA  …       
## 6 Olivia   Score    &lt;NA&gt;           3. &lt;NA&gt;    
## 7 Paul     Subject  &lt;NA&gt;          NA  NA      
## 8 Paul     Score    &lt;NA&gt;          NA  ..C</code></pre>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="tidy.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="pivot.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

</body>

</html>
