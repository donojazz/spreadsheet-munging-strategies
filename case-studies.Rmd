# Case studies

This is a collection of spreadsheets found in the wild.  Some are as easy to
mung as the examples; others are harder because their structure is less
consistent.

Seeing and reading the code will help you guage how much work is still involved
in munging a spreadsheet.  Attempting them for yourself and checking the model
answer will help you to hone your instincts.

The spreadsheet files are provided in the `smungs` package on GitHub.  Install
as follows.

```{r eval = FALSE}
# install.packages("devtools") # If you don't already have it
devtools::install_github("nacnudus/smungs")
```

## Australian Marriage Survey

[![Tweet by Miles McBain about tidying the Australian Marriage Survey results
with
R](images/ozmarriage_tweet.png)](https://twitter.com/MilesMcBain/status/932257990253645829)

These are the results of a survey in 2017 by the Australian Bureau of Statistics
that asked, "Should the law be changed to allow same-sex couples to marry?"

There are two tables with structures that are similar but different.  [Download
the
file](https://github.com/nacnudus/smungs/blob/master/inst/extdata/ozmarriage.xlsx?raw=true).
[Original source](http://www.abs.gov.au/ausstats/abs@.nsf/mf/1800.0).

![](images/ozmarriage1.png)

![](images/ozmarriage2.png)

### The full code listing

```{r}
cells <- xlsx_cells(smungs::ozmarriage)
formats <- xlsx_formats(smungs::ozmarriage)

table_1  <-
  cells %>%
  dplyr::filter(sheet == "Table 1", row >= 5L, !is_blank) %>%
  mutate(character = str_trim(character)) %>%
  behead("NNW", "population") %>%
  behead("NNW", "response") %>%
  behead("N", "unit") %>%
  behead("W", "state") %>%
  arrange(row, col) %>%
  select(row, data_type, numeric, state, population, response, unit) %>%
  spatter(unit) %>%
  select(-row)

state <-
  cells %>%
  dplyr::filter(sheet == "Table 2",
                row >= 5L,
                col == 1L,
                !is_blank,
                formats$local$font$bold[local_format_id]) %>%
  select(row, col, state = character)

table_2 <-
  cells %>%
  dplyr::filter(sheet == "Table 2",
                row >= 5L,
                !is_blank) %>%
  mutate(character = str_trim(character)) %>%
  behead("NNW", "population") %>%
  behead("NNW", "response") %>%
  behead("N", "unit") %>%
  behead("W", "territory") %>%
  enhead(state, "NNW") %>%
  arrange(row, col) %>%
  select(row, data_type, numeric, state, territory, population, response,
         unit) %>%
  spatter(unit) %>%
  select(-row)

all_tables <- bind_rows("Table 1" = table_1, "Table 2" = table_2, .id = "sheet")
all_tables
```

### Step by step

#### Table 1

The first rows, up to the column-headers, must be filtered out.  The trailing
rows below the table will be treated us row-headers, but because there is no
data to join them to, they will be dropped automatically.  That is handy,
because otherwise we would have to know where the bottom of the table is, which
is likely to change with later editions of the same data.

Apart from filtering the first rows, the rest of this example is 'textbook'.

```{r}
cells <- xlsx_cells(smungs::ozmarriage)

table_1  <-
  cells %>%
  dplyr::filter(sheet == "Table 1", row >= 5L, !is_blank) %>%
  mutate(character = str_trim(character)) %>%
  behead("NNW", "population") %>%
  behead("NNW", "response") %>%
  behead("N", "unit") %>%
  behead("W", "state") %>%
  arrange(row, col) %>%
  select(row, data_type, numeric, state, population, response, unit) %>%
  spatter(unit) %>%
  select(-row)

table_1
```

#### Table 2

This is like Table 1, broken down by division rather than by state.  The snag is
that the states are named in the same column as their divisions.  Because the
state names are formatted in bold, we can isolate them from the division names.
With them out of the way, unpivot the rest of the table as normal, and then use
`enhead()` at the end to join the state names back on.

Since tables 1 and 2 are so similar structurally, they might as well be joined
into one.

```{r}
cells <- xlsx_cells(smungs::ozmarriage)
formats <- xlsx_formats(smungs::ozmarriage)

state <-
  cells %>%
  dplyr::filter(sheet == "Table 2",
                row >= 5L,
                col == 1L,
                !is_blank,
                formats$local$font$bold[local_format_id]) %>%
  select(row, col, state = character)

table_2 <-
  cells %>%
  dplyr::filter(sheet == "Table 2",
                row >= 5L,
                !is_blank) %>%
  mutate(character = str_trim(character)) %>%
  behead("NNW", "population") %>%
  behead("NNW", "response") %>%
  behead("N", "unit") %>%
  behead("W", "territory") %>%
  enhead(state, "NNW") %>%
  arrange(row, col) %>%
  select(row, data_type, numeric, state, territory, population, response,
         unit) %>%
  spatter(unit) %>%
  select(-row)

all_tables <-
  bind_rows("Table 1" = table_1, "Table 2" = table_2, .id = "sheet") %>%
  select(sheet, state, territory, population, response, `%`, no.)
all_tables
```

## Vaccinations {#vaccinations}

[![Tweet by Bob Rudis challenging R users to tidy a particular spreadsheet](images/vaccinations_tweet.png)](https://twitter.com/hrbrmstr/status/890200287356620806)

This is a real-life example of [implied multiples](#implied-multiples).  Implied
multiples look like a single table, but many of the headers appear more than
once.  There is a dominant set of headers that are on the same 'level' (e.g. in
the same row) as the other headers.

In this case, there is a small multiple for each year of data.  The year headers
are highlighted in yellow in the screenshot.

The way to unpivot this is to realise that the year cells represent two
different things: the year (obviously) and a statistic (percentage vaccinated).
It would have been easier to unpivot if the years had been put into a separate
row of headers, so we will pretend that that was in fact the case.

1. Filter for the year cells and store in a variable to `enhead()` later.
1. `behead()` everything else as usual, and then overwite the year headers with
   `percentage_vaccinated`.
1. `enhead()` the year cells.

The original spreadsheet has been replaced by an [annual
refresh](https://www.cdc.gov/vaccines/vaxview/index.html), so you will need to
use the file from the [smungs](https://github.com/nacnudus/smungs) package.

```{r}
cells <- xlsx_cells(smungs::vaccinations, "SVV Coverage Trend Data")

years <-
  cells %>%
  dplyr::filter(row == 3,
                col >= 1,
                str_detect(character, "20[0-9]{2}-[0-9]{2}")) %>%
  select(row, col, year = character)
years

cells %>%
  select(row, col, data_type, character) %>%
  behead("NNW", "series") %>%
  behead("NNW", "population") %>%
  behead("W", "state") %>%
  behead("N", "header") %>%
  mutate(header = if_else(str_detect(header, "20[0-9]{2}-[0-9]{2}"),
                          "percent_vaccinated",
                          header),
         header = str_replace_all(str_to_lower(header), " ", "_")) %>%
  enhead(years, "NNW") %>%
  select(row, series, population, state, year, header, character) %>%
  spatter(header, character) %>%
  select(series, population, state, year, percent_vaccinated, percent_surveyed,
         everything())
```
